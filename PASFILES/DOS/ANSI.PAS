{$A+,B-,D-,E-,F-,G-,I-,L-,N-,O-,P-,Q-,R-,S-,T-,V-,X-}
(*===================================================================*)
(*                              ANSI.PAS                             *)
(*            Copyright (C) 1993 te-wi Verlag, MÅnchen               *)
(*    Die Unit stellt ein Inferface zum ANSI-Treiber zur VerfÅgung   *)
(*===================================================================*)

UNIT ANSI;

INTERFACE

VAR
  CON: Text;

(*   öberprÅfung, ob ein ANSI-Treiber installiert ist                *)
FUNCTION AnsiSys: BOOLEAN;

(* öbergabe von beliebigen Werten an den ANSI-Treiber                *)
PROCEDURE AnsiOut(s: SHORTINT);

(* ANSI-Farbeinschaltung: Attribut 7 = grau                          *)
PROCEDURE AnsiGray;

(* ANSI-Farbeinschaltung: Attribut 15 = wei·                         *)
PROCEDURE AnsiWhite;

(* ANSI-Farbeinschaltung: Attribut 14 = gelb                         *)
PROCEDURE AnsiYellow;

IMPLEMENTATION

USES
  Crt;

CONST
  ESC = #27;
  ansiinstalled: BOOLEAN = FALSE;

FUNCTION AnsiSys: BOOLEAN;
(* Test ob ANSI.SYS installiert ist; da alle Ausgaben Åber die       *)
(* Standard-Ausgabe gehen, mÅssen die Bildschirmfarben Åber ANSI-Se- *)
(* quenzen gesteuert werden. Ist ANSI.SYS nicht installiert, werden  *)
(* keine ANSI-Steuerbefehle vom Programm ausgegeben.                 *)
VAR
  posold,
  posnew  : BYTE;
BEGIN
  AnsiSys := FALSE;
  posold  := WhereX;                                (* Spalte merken *)
  Write(CON, Chr(27), '[2m');                       (* ANSI-Sequenz  *)
  posnew  := WhereX;                                (* neue Position *)

  IF posnew = posold THEN AnsiSys := TRUE;(*Sequenz wurde verarbeitet*)

  GotoXY(1, WhereY);                             (* evtl. vorhandene *)
  ClrEoL;                                        (* Zeichen lîschen  *)
END;

(*-------------------------------------------------------------------*)

PROCEDURE AnsiOut(s: SHORTINT);
BEGIN
  Write(CON, ESC + '[' , s , 'm');
END;

(*-------------------------------------------------------------------*)

PROCEDURE AnsiGray;
BEGIN
  IF ansiinstalled THEN AnsiOut(0);
END;

(*-------------------------------------------------------------------*)

PROCEDURE AnsiWhite;
BEGIN
  IF ansiinstalled THEN
  BEGIN
    AnsiOut(0);
    AnsiOut(1);
  END;
END;

(*-------------------------------------------------------------------*)

PROCEDURE AnsiYellow;
BEGIN
  IF ansiinstalled THEN AnsiOut(33);
END;

VAR
  OldExitProc: Pointer;

{$F+}
PROCEDURE ANSIExitProc;
VAR
  ExitProc: POINTER;
BEGIN
  Close(CON);
  ExitProc := OldExitProc;
END;
{$F-}

(*-------------------------------------------------------------------*)

BEGIN
  Assign(CON, '');
  Append(CON);
  ansiinstalled := AnsiSys;
  OldExitProc := ExitProc;
  ExitProc := @ANSIExitProc;
END.

(*===================================================================*)
